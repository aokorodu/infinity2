package com.shearspire {		import flash.data.*;	import flash.desktop.*;	import flash.errors.*;	import flash.events.*;	import flash.filesystem.*;	import flash.net.*;	import flash.system.System;	import flash.utils.*;	import com.adobe.serialization.json.JSON;	import com.adobe.serialization.json.JSONDecoder;		public class Search {		//SQLite stuff		public static var defaultDirectory:File = File.documentsDirectory; // The documents directory - better choice than File.applicationStorageDirectory;		public static var sqldirectory:File;		public static var xmldirectory:File;		public static var posterdirectory:File;		public static var imdbposterdirectory:File;		public static var rtposterdirectory:File;		public static var thumbdirectory:File;		public static var conn:SQLConnection;		public static var selectStatement:SQLStatement;		public static var selectSeriesStatement:SQLStatement;		public static var replaceStatement:SQLStatement;		public static var createStatement:SQLStatement;		public static var syncStatement:SQLStatement;				public static var ids3D:Array;		public static var channelXML:XML;		public static var channelData:Array;		public static var validSourceIDs:Array;		public static var validChannels:Array;		public static var validNetcalls:Array;		public static var allFields:Array = new Array();		public static var floatFlds:Array = new Array("boost","entityRank","score","searchEntityRank");		public static var boolFlds:Array = new Array("isadult","newForRelevance");		public static var dateFlds:Array = new Array();		public static var intFlds:Array = new Array("adminRank","entityRankOrder","numVods","releaseYear","tpv_grp_vod_week_global","tpv_grp_vod_week_movies","tpv_grp_vod_week_others");		public static var longFlds:Array = new Array("gwtvProgramid","muid","parentid","rbid","roviProgramid");		public static var strFlds:Array = new Array("audience","description","descriptionLong","endYear","entityType","episodeno","gwtvSeriesid","id","language","mpaaRating","originalAirDate","parentTitle","roviSeriesid","seasonno","starRating","startYear","title","titleSort","titlestartcharacter","topCategory","topCategoryName","tvRating");		public static var arrFlds:Array = new Array("genreSearch","hasSW","ids","ithemesSearch","tokens");		public static var arrTableFlds:Array = new Array("creditDetails","gwtvshowings","rec_for","sportsDetails","vodcategorypaths","vodshowings");		public static var arrOtherFlds:Array = new Array("childLinks","childLinkTypes","genre","genreSquishSearch","idNamespaces","interFragments","ithemes","odoldevicetypes","odolshowings","startFragments","synonymsSearch","synonymsStartFragments","synonymsTitleFragments","t9interFragments","t9numberInTitleFragments","t9startFragments","t9titleCompressed","t9titleFragments","t9titleSearch","t9tokens","titleCompressed","titleFragments","titleSearch");		public static var integerFields:Array = new Array("programSerialNumber","position","billing","duration","runTime","sn1","sn2","rank");				public static var processStart:Date;		public static var processEnd:Date;		public static var programSet:String = "integrated";		public static var fieldLists:Array = new Array();		public static var initializer:Object;				public static var ready:Boolean = false;		//tables from the sql database		public static var tables:Array = new Array();		public static var tableNames:Array = new Array("vodcategorypaths","programs","creditDetails","sportsDetails","linearshowings","vodshowings","aidids","molt","tomatoes","imdb");		public static var tableLoading:int = 0;		//processed arrays of info objects derived from the tables in the sql database		public static var infoArrays:Array = new Array();		public static var seriesFolderIds:Array = new Array();		public static var seriesFolderIdsIndex:Array = new Array();		public static var selectedSns:Array = new Array();		public static var selectedIDs:Array = new Array();		public static var showingSn:int = 0;				public static var today:Date;		public static var tonight:Date;		public static var tonightnum:Number;		public static var midnight:Date;		public static var tomorrow6AM:Date;		public static var timevalue1:Number = 0;		public static var timevalue2:Number = 9999999900000;				public static var posterPath:String;		public static var searchTerm:String;		public static var posterFileList:Array;		public static var imdbPosterFileList:Array;		public static var rtPosterFileList:Array;		public static var thumbFileList:Array;				public static var defaultTomatoPosters:Array = new Array();				public static var tempGenre:String = "";//for use in genre searches. to feed a value to the hasGenre filter		//lookups		public static var parentidLookup:Array = new Array();		public static var idLookup:Array = new Array();				/**		 * The Search class contains public static functions only. Call these functions using Search.someFunction() syntax.		 * Do not instantiate the Search class.		 * Here is a summary of the types of objects stored by the Search class.		 * <p>PROGRAM OBJECTS: each program object has the following properties:		 *   (serialNumber INTEGER PRIMARY KEY, accessType TEXT, boost TEXT, entityRank TEXT, score TEXT, searchEntityRank TEXT, isadult TEXT, 		 *   newForRelevance TEXT, adminRank TEXT, entityRankOrder TEXT, numVods TEXT, releaseYear TEXT, tpv_grp_vod_week_global TEXT, 		 *   tpv_grp_vod_week_movies TEXT, tpv_grp_vod_week_others TEXT, gwtvProgramid TEXT, muid TEXT, parentid TEXT, rbid TEXT, roviProgramid TEXT, 		 *   audience TEXT, description TEXT, descriptionLong TEXT, endYear TEXT, entityType TEXT, episodeno TEXT, gwtvSeriesid TEXT, id TEXT, language TEXT, 		 *   mpaaRating TEXT, originalAirDate TEXT, parentTitle TEXT, roviSeriesid TEXT, seasonno TEXT, starRating TEXT, startYear TEXT, 		 *   title TEXT, titleSort TEXT, titlestartcharacter TEXT, topCategory TEXT, topCategoryName TEXT, tvRating TEXT, genreSearch TEXT, hasSW TEXT, 		 *   ids TEXT, ithemesSearch TEXT, tokens TEXT, hasHD TEXT, has3D TEXT, isFree TEXT, date1 TEXT, date2 TEXT)		 * <p>When folderized, program objects also contain group_concat(serialNumber) as folderIds,Count(serialNumber) as folderCount,group_concat(date1) as folderDates,		 *   min(date1) as folderDate1,min(date2) as folderDate2,group_concat(accessType) as folderTypes		 * <p>CREDITDETAILS OBJECTS:  (recordNumber INTEGER PRIMARY KEY, role TEXT, fullname TEXT, billing INTEGER, programSerialNumber INTEGER)		 * <p>SPORTSDETAILS OBJECTS: (recordNumber INTEGER PRIMARY KEY, code TEXT, category TEXT, content TEXT, programSerialNumber INTEGER)		 * <p>IMDB OBJECTS: (recordNumber INTEGER PRIMARY KEY, json TEXT, description TEXT, id TEXT, posterURL TEXT)		 * <p>TOMATOES OBJECTS: 		 *   (recordNumber INTEGER PRIMARY KEY, json TEXT, id TEXT, posterURL TEXT, 		 *   critics_consensus TEXT, critics_rating TEXT, critics_score INTEGER, audience_rating TEXT, audience_score INTEGER)		 * <p>VODSHOWINGS OBJECTS: 		 *   (recordNumber INTEGER PRIMARY KEY, assetId TEXT, providerId TEXT, licenseStart TEXT, licenseEnd TEXT, runTime INTEGER, price TEXT, 		 *   contentLabel TEXT, audience TEXT, captioning TEXT, tvRating TEXT, displayFlag TEXT, audioType TEXT, screenFormat TEXT, vodFormat TEXT,		 *   isAdult TEXT, free TEXT, svod TEXT, providerDisplayCode TEXT, callLetter TEXT, providerCode TEXT, programSerialNumber INTEGER)		 * <p>LINEARSHOWINGS OBJECTS:		 *   (recordNumber INTEGER PRIMARY KEY, sourceID TEXT, channel INTEGER, netcall TEXT, startTime TEXT, endTime TEXT, effectiveFlag TEXT, duration INTEGER, tvRating TEXT, 		 *   audioLevel TEXT, hdLevel TEXT, programAiringType TEXT, captionType TEXT, programSerialNumber INTEGER)		 * <p>MOLT OBJECTS: (recordNumber INTEGER PRIMARY KEY, id TEXT, ids ARRAY, similarIDS TEXT),		 * <p>AIDIDS OBJECTS: (aid text,id text,programSerialNumber INTEGER,recordNumber INTEGER PRIMARY KEY)		 * <p>VODCATEGORYPATHS OBJECTS: (recordNumber INTEGER PRIMARY KEY, path TEXT, programSerialNumbers TEXT)		 * <p>ARRAYS FOR THESE OBJECTS: "vodcategorypaths","programs","creditDetails","sportsDetails","linearshowings","vodshowings","aidids","molt","tomatoes","imdb"		 */		public function Search() {					}		/**		 * Use the init function to start the Search class.		 * The Search class expects to find the database simdatatool.sqlite in a directory called SimDataToolFiles in the user's Documents folder.		 * The Search class also expects to find directories of posters within the application directory of whatever application initializes this class		 * @param obj the object initializing the Search class (usually 'this')		 * @param year an integer for the year portion of the earliest date in the database. The provider of the database will supply this value.		 * @param month an integer for the month portion of the earliest date in the database. The provider of the database will supply this value.		 * @param date an integer for the date portion of the earliest date in the database. The provider of the database will supply this value.		 * @example <code>Search.init(this,2012,0,10);</code>		 * @returns nothing		 */		public static function init(obj:Object,year:int,month:int,date:int):void {			var i:int=0;			initializer = obj;			setupDates(year,month-1,date);//Change date here when using a new set of program data or call anytime to set the dates			SSUtils.setNetCalls();			setupDirectories();							SSUtils.loadXML(xmldirectory.url + "/ComcastChannels.xml",Search.parseChannels);						allFields = new Array("serialNumber","accessType");			allFields = allFields.concat(floatFlds,boolFlds,dateFlds,intFlds,longFlds,strFlds,arrFlds);			allFields.push("hasHD","has3D","isFree","date1","date2");						conn = new SQLConnection();			conn.addEventListener(SQLEvent.OPEN, connOpenHandler);			createStatement = new SQLStatement();			selectStatement = new SQLStatement();			syncStatement = new SQLStatement();			replaceStatement = new SQLStatement();			selectSeriesStatement = new SQLStatement();						createStatement.sqlConnection = conn;			selectStatement.sqlConnection = conn;			syncStatement.sqlConnection = conn;			replaceStatement.sqlConnection = conn;			selectSeriesStatement.sqlConnection = conn;						var dbFile:File = sqldirectory.resolvePath("simdatatool.sqlite");			//if (dbFile.exists) dbFile.deleteFile();			conn.open(dbFile);						for (i=0;i<tableNames.length;i++){				tables[tableNames[i]] = new Array();			}		}		public static function setupDirectories():void {			sqldirectory = defaultDirectory.resolvePath("SimDataToolFiles");			xmldirectory = defaultDirectory.resolvePath("SimDataToolFiles/xml");			posterdirectory = defaultDirectory.resolvePath("SimDataToolFiles/posters");			imdbposterdirectory = defaultDirectory.resolvePath("SimDataToolFiles/imdbposters");			rtposterdirectory = defaultDirectory.resolvePath("SimDataToolFiles/rottentomatoesposters");			thumbdirectory = defaultDirectory.resolvePath("SimDataToolFiles/thumbs");			updatePosterList();			updateIMDBPosterList();			updateRottenTomatoesPosterList();			updateThumbList();		}//---------------------------------------------------------------------------------------------------------------------------		//SEARCH MAIN FUNCTIONS		/**		 * gets a copy of the vodcategorypaths array containing all the native on demand paths associated with the programs in the database		 * @returns an array of native path strings (ex. Movies/By Genre/Drama)		 */		public static function getVodCategoryPaths():Array {			return tables["vodcategorypaths"].slice();		}		/**		 * USE WITH CARE. This retrieves the infoArrays array of folderized and unfolderized program object arrays		 * @returns an array of program object arrays		 */		public static function getInfoArrays():Array {			return infoArrays;		}		/**		 * USE WITH CARE. This retrieves the tables array of program object arrays		 * @returns an array of program object arrays		 */		public static function getTables():Array {			return tables;		}		/**		 * gets an array of folderized program objects associated with a given top category (Movies, Sports, Kids, Tv, Adult);		 * @param pset the program set (integrated, vod, or linear)		 * @param tc the top category ("Movies","Sports","Kids","Tv","Adult")		 * @example <code>Search.getTopCategory("vod","Movies");</code>		 * @returns an array of program objects		 */		public static function getTopCategory(pset:String,tc:String):Array {			pset = pset.toLowerCase();			var validCats:Array = new Array("Movies","Sports","Kids","Tv","Adult");			tc = SSUtils.toTitleCase(tc);			if (validCats.indexOf(tc) < 0) tc = "Movies";			if (pset == "integrated") return infoArrays[tc];			return pset == "vod" ? infoArrays["vod" + tc] : infoArrays["linear" + tc];		}		/**		 * gets an array of program objects associated with a given serialNumber;		 * @param sn the serialNumber value		 * @example <code>Search.getBySerialNumber(1536);</code>		 * @returns an array of program objects that will most likely have a length of 1		 */		public static function getBySerialNumber(sn:int):Array {			selectedSns = [String(sn)];			//trace ("selectedIds is " + selectedSns);			var arr:Array = tables["programs"].filter(isRequestedSn);			return arr;		}		/**		 * gets an array of program objects associated with a given array of serialNumber values;		 * @param sns an array of serialNumber values each of which can be an integer or string		 * @example <code>Search.getBySerialNumbers(snsarray);</code>		 * @returns an array of program objects that will most likely have a length equal to the length of the array passed to the function		 */		public static function getBySerialNumbers(sns:Array):Array {			selectedSns = sns.toString().split(",");//in case the sns array was an array of integers			//trace ("selectedIds is " + selectedSns);			var arr:Array = tables["programs"].filter(isRequestedSn);			return arr;		}		/**		 * gets an array of folderized program objects associated with a given search term and accessType;		 * @param term a plain text string to search		 * @param accessType string either vod, linear, or integrated (the default)		 * @example <code>Search.getBySearchTerm("Batman","vod");</code>		 * @returns an array of program objects that will most likely have a length equal to the length of the array passed to the function		 */		public static function getBySearchTerm(term:String,accessType:String):Array {			searchTerm = term.toUpperCase();			accessType = accessType.toLowerCase();			var arr:Array = infoArrays["allFolderized"].filter(bySearchTerm);			if (accessType == "vod") arr = arr.filter(isVOD);			if (accessType == "linear") arr = arr.filter(isLinear);			return arr;		}		/**		 * gets an array of showings objects that end before the "tonight" time. Ideally there should be none in the database;		 * @example <code>Search.getShowingsOnBeforeNow();</code>		 * @returns an array of showings objects that will most likely have a length of 0		 */		public static function getShowingsOnBeforeNow():Array {			var arr:Array = tables["linearshowings"].filter(byOnBeforeNow);			arr = arr.filter(byValidSource);			arr.sortOn(["channel","startTime"],[Array.NUMERIC,Array.NUMERIC]);			return arr;		}		/**		 * gets an array of showings objects that end after the "tonight" time and begin before the "tonight" time.		 * @example <code>Search.getShowingsOnNow();</code>		 * @returns an array of showings objects that will most likely have a length of about two hundred showings		 */		public static function getShowingsOnNow():Array {			var arr:Array = tables["linearshowings"].filter(byOnNow);			arr = arr.filter(byValidSource);			arr.sortOn(["channel","startTime"],[Array.NUMERIC,Array.NUMERIC]);			return arr;		}		/**		 * gets an array of showings objects that begin after the "tonight" time and begin before the "midnight" time.		 * @example <code>Search.getShowingsOnTonight();</code>		 * @returns an array of showings objects that will most likely have a length of about several hundred showings		 */		public static function getShowingsOnTonight():Array {			var arr:Array = tables["linearshowings"].filter(byOnTonight);			arr = arr.filter(byValidSource);			arr.sortOn(["channel","startTime"],[Array.NUMERIC,Array.NUMERIC]);			return arr;		}		/**		 * gets an array of showings objects that begin on or after t1 and end on or before t2		 * @param t1 a number such as 1327217400000 representing a date and time in utc		 * @example <code>Search.getShowingsByRange(1326886200000,1327172400000);</code>		 * @returns an array of showings objects		 */		public static function getShowingsByRange(t1:Number,t2:Number):Array {			Search.timevalue1 = t1;			Search.timevalue2 = t2;			var arr:Array = tables["linearshowings"].filter(byTimeRange);			arr = arr.filter(byValidSource);			arr.sortOn(["channel","startTime"],[Array.NUMERIC,Array.NUMERIC]);			return arr;		}		/**		 * gets an array of genres associated with a set of programs. This is useful for parametric browsing.		 * @param progs an array of program objects (probably the array currently displayed in a listings module on screen)		 * @example <code>Search.getGenreList(currentListingsArray);</code>		 * @returns an array of genres found in progs		 */		public static function getGenreList(progs:Array):Array {			//returns an array of genre values that exist within the array of program objects passed to the function			var genres:Array = new Array();			var i:int = 0;			for (i=0;i<progs.length;i++){				var glist:Array = progs[i].genreSearch.split("|");				for (var j:int=0;j<glist.length;j++){					if (genres.indexOf(glist[j]) < 0){						if (glist[j] > "a") genres.push(glist[j]);					}				}			}			genres.sort();			return genres;		}		/**		 * gets an array of creditDetails objects associated with a given program object;		 * @param sn a program object serialNumber value		 * @example <code>Search.getCreditDetails(5339);</code>		 * @returns an array of creditDetails objects with fullname, role, and billing properties.		 */		public static function getCreditDetails(sn:int):Array {			selectedSns = [String(sn)];			//trace ("selectedIds for credit details is " + selectedSns);			var arr:Array = tables["creditDetails"].filter(isRequestedPsn);			return arr;		}		/**		 * gets an array of sportsDetails objects associated with a given program object;		 * @param sn a program object serialNumber value		 * @example <code>Search.getSportsDetails(5339);</code>		 * @returns an array of sportsDetails objects with category, content, and code properties.		 */		public static function getSportsDetails(sn:int):Array {			selectedSns = [String(sn)];			//trace ("selectedIds for sports details is " + selectedSns);			var arr:Array = tables["sportsDetails"].filter(isRequestedPsn);			return arr;		}		/**		 * gets an array of vodshowings objects associated with a given program object;		 * @param sn a program object serialNumber value		 * @example <code>Search.getVODShowings(5339);</code>		 * @returns an array of vodshowings objects. See the constructor function for a list of properties.		 */		public static function getVODShowings(sn:int):Array {			showingSn = sn;			var arr:Array = tables["vodshowings"].filter(isShowingSn);			return arr;		}		/**		 * gets an array of linearshowings objects associated with a given program object;		 * @param sn a program object serialNumber value		 * @example <code>Search.getLinearShowings(5339);</code>		 * @returns an array of linearshowings objects. See the constructor function for a list of properties.		 */		public static function getLinearShowings(sn:int):Array {			showingSn = sn;			var arr:Array = tables["linearshowings"].filter(isShowingSn);			arr.sortOn(["startTime","channel"],[Array.NUMERIC,Array.NUMERIC]);			return arr;		}		/**		 * gets an imdb object associated with a given program object id or parentid;		 * @param id a program object id or parentid string (pass parentid when seeking series info)		 * @example <code>Search.getIMDB(50085);</code>		 * @returns a tomatoes object. See the constructor function for a list of properties.		 */		public static function getIMDB(id:String):Object {			selectedIDs = new Array(id);			var arr:Array = tables["imdb"].filter(isRequestedID);			if (arr.length > 0){				////trace ("getRottenTomatoes returns critics_score: " + arr[0].critics_score);				return arr[0];			}else{				////trace ("getRottenTomatoes returns nothing.");			}			return new Object();		}		/**		 * gets a tomatoes object associated with a given program object;		 * @param sn a program object serialNumber value		 * @example <code>Search.getRottenTomatoes(5339);</code>		 * @returns a tomatoes object. See the constructor function for a list of properties.		 */		public static function getRottenTomatoes(sn:int):Object {			selectedIDs = new Array(idLookup[sn]);			var arr:Array = tables["tomatoes"].filter(isRequestedID);			if (arr.length > 0){				////trace ("getRottenTomatoes returns critics_score: " + arr[0].critics_score);				return arr[0];			}else{				////trace ("getRottenTomatoes returns nothing.");			}			return new Object();		}		/**		 * gets a an array of program object serial numbers given an array of ids;		 * @param ids an array of program object id values		 * @example <code>Search.getSNSfromIDS(['11668990400','118920400','1194880400','153680400','112104370400','1288080400','196002390400','1119640400','125406920400','128069820402']);</code>		 * @returns an array of serial numbers of program objects that have ids or parentids included in the array passed.		 */		public static function getSNSfromIDS(ids:Array):Array {			var snarr:Array = new Array();			syncStatement.text = "SELECT serialNumber from programs where id in (" + ids.toString() + ") or parentid in (" + ids.toString() + ");";			syncStatement.execute();			var result:SQLResult = syncStatement.getResult();			if (result.hasOwnProperty('data') && result.data != null) {				for (var i:int=0;i<result.data.length;i++){					snarr.push(result.data[i].serialNumber);				}			}			return snarr;		}		/**		 * gets a program object clone with the description for the series as well as all the usual series data like startYear, endYear, etc.;		 * @param pid String value (the parentid property of a program for which you seek series info)		 * @example <code>Search.getSeriesInfo("11668990400");</code>		 * @returns an Object with standard program object properties.		 */		public static function getSeriesInfo(pid:String):Object {			var summary:Object = new Object();			var sinfo:Array = new Array();			var i:int = 0;			syncStatement.text = "SELECT * from programs where parentid = " + pid + " order by entityType DESC, date1;";			syncStatement.execute();			var result:SQLResult = syncStatement.getResult();			if (result.hasOwnProperty('data') && result.data != null) {				sinfo = result.data;			}			if (sinfo.length == 0){				return summary;			}else{				summary = sinfo[0];				summary.description = "TV Series";				var hasSeries:Boolean = false;				for (i=1;i<sinfo.length;i++){					if (sinfo[i].entityType == "Series"){						summary = sinfo[i];						hasSeries = true;					}				}				if (!hasSeries){					var imdbInfo:Object = getIMDB(summary.parentid);					if (imdbInfo.description != undefined){						summary.description = imdbInfo.description.length > 4 ? imdbInfo.description : "TV Series";					}				}			}			return summary;		}		/**		 * gets a molt array associated with a given program object;		 * @param sn a program object serialNumber value		 * @example <code>Search.getMolt(5339);</code>		 * @returns an array of serial numbers of program objects similar to the one passed to the function. See the constructor function for a list of properties.		 */		public static function getMolt(sn:int):Array {			selectedIDs = new Array(idLookup[sn]);						var arr:Array = tables["molt"].filter(isRequestedID);			if (arr.length > 0){				var tarr:Array = arr[0].ids;				var snarr:Array = getSNSfromIDS(tarr);				//trace ("getMolt returns : " + snarr);				return snarr;			}			//trace ("getMolt returns nothing.");			return new Array();		}		/**		 * gets a channel number associated with a given showing object;		 * @param showing a showing object (linearshowing)		 * @example <code>Search.getChannelFromShowing(myshow);</code>		 * @returns an integer for the channel number.		 */		public static function getChannelFromShowing(showing:Object):int {			var sourceID:String = showing.sourceID;			//trace ("showing object passed has sourceID of " + sourceID);			return getChannelFromSourceID(sourceID);		}		/**		 * gets a channel number associated with a given sourceID;		 * @param sourceID a string representation of the sourceID property of a linearshowing object		 * @example <code>Search.getChannelFromSourceID("1021");</code>		 * @returns an integer for the channel number.		 */		public static function getChannelFromSourceID(sourceID:String):int {			var channel:int = 0;			var sin:int = Search.validSourceIDs.indexOf(sourceID);			if (sin >= 0){				channel = Search.validChannels[sin];			}					return channel;		}		/**		 * gets a netcall string associated with a given showing object;		 * @param showing a showing object (linearshowing or vodshowing)		 * @example <code>Search.getNetcallFromShowing(myshow);</code>		 * @returns a string for the network call letters.		 */		public static function getNetcallFromShowing(showing:Object):String {			var sourceID:String = showing.sourceID;			var netcall:String = "";			var i:int = 0;			for (i=0;i<channelData.length;i++){				if (channelData[i].id == sourceID){					netcall = channelData[i].netcall;				}			}						return netcall;		}		/**		 * gets a netcall string associated with a given sourceID;		 * @param sourceID a string representation of the sourceID property of a showing object		 * @example <code>Search.getNetcallFromSourceID(myshow);</code>		 * @returns a string for the network call letters.		 */		public static function getNetcallFromSourceID(sourceID:String):String {			var netcall:String = "";			var sin:int = Search.validSourceIDs.indexOf(sourceID);			if (sin >= 0){				netcall = Search.validNetcalls[sin];			}			return netcall;		}		/**		 * gets a an array of SQL result objects given a string of sql;		 * @param sql String for the sql statement (SELECT only, no DELETE or UPDATE statements)		 * @example <code>Search.getBySQL("SELECT * from tomatoes");</code>		 * @returns an array of SQL result objects or an empty array if no results or error.		 */		public static function getBySQL(sql:String):Array {			if (sql.toUpperCase().indexOf("SELECT") != 0){				return new Array();			}			try {				syncStatement.text = sql;				syncStatement.execute();				var result:SQLResult = syncStatement.getResult();				if (result.hasOwnProperty('data') && result.data != null) {					return result.data;				}else{					return new Array();				}			}			catch (error:SQLError) {				//trace("Error getting program data:", error);				//trace("error.message:", error.message);				//trace("error.details:", error.details);				return new Array();			}			return new Array();		}		//---------------------------------------------------------------------------------------------------------------------------		//Functions to set values used in filters		/**		 * sets the searchTerm var to a given value		 */		public static function setSearchTerm(term:String):void {			searchTerm = term.toUpperCase();		}		/**		 * sets the tempGenre var to a given value		 */		public static function setTempGenre(genre:String):void {			tempGenre = genre;		}		/**		 * sets the selectedSns var to a given array of values		 */		public static function setSelectedSns(sns:Array):void {			selectedSns = sns;		}		/**		 * sets the selectedIDs var to a given array of values		 */		public static function setSelectedIDs(ids:Array):void {			selectedIDs = ids;		}		/**		 * sets the timevalue1 and timevalue2 vars		 */		public static function setTimeValues(t1:Number,t2:Number):void {			timevalue1 = t1;			timevalue2 = t2;		}//---------------------------------------------------------------------------------------------------------------------------		//FILTERS for Arrays		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * if called independently, be sure to first call setSearchTerm		*/		public static function bySearchTerm(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("title")){				var comp:String = element.title.toUpperCase();				bool = searchTerm.length > 3 ? comp.indexOf(searchTerm) >= 0 : comp.indexOf(searchTerm) == 0;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of showing objects		 */		public static function byOnBeforeNow(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("startTime")){				var et:Number = Number(element.endTime);				if (et < Search.tonightnum) bool = true;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of showing objects		 */		public static function byOnNow(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("startTime")){				var st:Number = Number(element.startTime);				var et:Number = Number(element.endTime);				if (st <= Search.tonightnum && et > Search.tonightnum) bool = true;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of showing objects		 */		public static function byValidSource(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("sourceID")){				var sid:String = String(element.sourceID);				if (validSourceIDs.indexOf(sid) >= 0) bool = true;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of showing objects		 */		public static function byOnTonight(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("startTime")){				var st:Number = Number(element.startTime);				var et:Number = Number(element.endTime);				if (st >= Search.tonightnum && et <= Search.tomorrow6AM.time) bool = true;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of showing objects		 * if called independently, be sure to first call setTimeValues		 */		public static function byTimeRange(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("startTime")){				var st:Number = Number(element.startTime);				var et:Number = Number(element.endTime);				if (st >= Search.timevalue1 && et <= Search.timevalue2) bool = true;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of showing objects		 */		public static function isShowingSn(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("programSerialNumber")){				bool = element.programSerialNumber == showingSn;				if (element.hasOwnProperty("endTime")){					if (element.endTime < Search.tonightnum){						bool = false;					}				}			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of objects		 * if called independently, be sure to first call setSelectedSns and pass an array		 */		public static function isRequestedSn(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("serialNumber")){				bool = selectedSns.indexOf(String(element.serialNumber)) >= 0;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of objects		 * if called independently, be sure to first call setSelectedIDs and pass an array		 */		public static function isRequestedID(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("id")){				bool = selectedIDs.indexOf(String(element.id)) >= 0;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of objects		 * if called independently, be sure to first call setSelectedSns and pass an array		 */		public static function isRequestedPsn(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("programSerialNumber")){				bool = selectedSns.indexOf(String(element.programSerialNumber)) >= 0;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isVOD(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("accessType")){				bool = element.accessType == "vod";			}			if (element.hasOwnProperty("folderTypes")){				bool = bool == true ? bool : element.folderTypes.indexOf("vod") >= 0;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isLinear(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("accessType")){				bool = element.accessType == "linear";			}			if (element.hasOwnProperty("folderTypes")){				bool = bool == true ? bool : element.folderTypes.indexOf("linear") >= 0;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isMovie(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("topCategoryName")){				bool = element.topCategoryName == "Movies";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isSports(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("topCategoryName")){				bool = element.topCategoryName == "Sports";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isKids(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("topCategoryName")){				bool = element.topCategoryName == "Kids";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isTV(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("entityType")){				bool = element.entityType == "Series" || element.entityType == "Episode";			}			if (element.hasOwnProperty("topCategoryName")){				if (element.topCategoryName != "Other") bool = false;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isSeriesRecord(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("entityType")){				bool = element.entityType == "Series";			}			if (element.hasOwnProperty("topCategoryName")){				if (element.topCategoryName != "Other") bool = false;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isOther(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("entityType")){				bool = element.entityType == "Other";			}			if (element.hasOwnProperty("topCategoryName")){				if (element.topCategoryName != "Other") bool = false;			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isAdult(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("isadult")){				bool = element.isadult == "true";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isNotAdult(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("isadult")){				bool = element.isadult != "true";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 */		public static function isHD(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("hasHD")){				bool = element.hasHD == "true";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function is3D(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("has3D")){				bool = element.has3D == "true";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isFree(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("isFree")){				bool = element.isFree == "true";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isNew(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("newForRelevance")){				bool = element.newForRelevance == "true";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of Spanish program objects		 * but can be called independently to filter any array of program objects		 */		public static function isEsp(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("language")){				bool = element.language == "spa";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * but can be called independently to filter any array of program objects		 */		public static function isEnding(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("date2")){				bool = Number(element.date2) < ( tonightnum + (30 * 24 * 60 * 60 * 1000) ) && element.accessType == "vod";			}			return bool;		}		/**		 * used by the SEARCH MAIN FUNCTIONS for filtering arrays of program objects		 * if called independently, be sure to first call setTempGenre and pass a genre name		 */		public static function hasGenre(element:*, index:int, arr:Array):Boolean {			var bool:Boolean = false;			if (element.hasOwnProperty("genreSearch")){				bool = element.genreSearch.indexOf(tempGenre) >= 0;			}			return bool;		}				//---------------------------------------------------------------------------------------------------------------------------		//Functions to get and maintain poster image paths		/**		 * gets a url string for the default poster jpg		 */		public static function getDefaultPosterPath():String {			var path:String = posterdirectory.url + "/posterdefault.jpg";			return path;		}		/**		 * gets a url string for the default thumbnail jpg		 */		public static function getDefaultThumbPath():String {			var path:String = thumbdirectory.url + "/thumbdefault.jpg";			return path;		}		/**		 * gets a url string for the imdb poster jpg		 * @param row a program object		 * @param update a Boolean, if true the poster list will update by scanning the directory, set to false for best performance		 * @example <code>Search.getIMDBPosterPath(myprogram,false);</code>		 * @returns a url string.		 */		public static function getIMDBPosterPath(row:Object,update:Boolean=false):String {			if (update) updateIMDBPosterList();			var isSeries:Boolean = row.entityType == "Episode" || row.entityType == "Series";			var pid:String = isSeries ? row.parentid : row.id;			var filename:String = "imdbposter" + pid + ".jpg";			if (imdbPosterFileList.indexOf(filename) >= 0){				var path:String = imdbposterdirectory.url + "/" + filename;				return path;			}			return "";		}		public static function checkIMDBPosterPath(filename:String):String {			//updateIMDBPosterList();			if (imdbPosterFileList.indexOf(filename) >= 0){				var path:String = imdbposterdirectory.url + "/" + filename;				return path;			}			return "";		}		/**		 * gets a url string for the rotten tomatoes poster jpg		 * @param row a program object		 * @param update a Boolean, if true the poster list will update by scanning the directory, set to false for best performance		 * @example <code>Search.getRottenTomatoesPosterPath(myprogram,false);</code>		 * @returns a url string.		 */		public static function getRottenTomatoesPosterPath(row:Object,update:Boolean):String {			if (update) updateRottenTomatoesPosterList();			var isMovie:Boolean = row.entityType == "Movie";			var pid:String = row.id;			var filename:String = "rtposter" + pid + ".jpg";			if (rtPosterFileList.indexOf(filename) >= 0){				var path:String = rtposterdirectory.url + "/" + filename;				return path;			}			return "";		}		public static function checkRottenTomatoesPosterPath(filename:String):String {			//updateRottenTomatoesPosterList();			if (rtPosterFileList.indexOf(filename) >= 0){				var path:String = rtposterdirectory.url + "/" + filename;				return path;			}			return "";		}		/**		 * gets a url string for the streamsage poster jpg - these are often landscape rather than portrait in orientation		 * @param row a program object		 * @param update a Boolean, if true the poster list will update by scanning the directory, set to false for best performance		 * @example <code>Search.getPosterPath(myprogram,false);</code>		 * @returns a url string.		 */		public static function getPosterPath(row:Object,update:Boolean):String {			if (update) updatePosterList();			var isSeries:Boolean = row.entityType == "Episode" || row.entityType == "Series";			var pid:String = isSeries ? row.parentid : row.id;			var filename:String = "poster" + pid + ".jpg";			if (posterFileList.indexOf(filename) >= 0){				var path:String = posterdirectory.url + "/" + filename;				return path;			}			return "";		}		/**		 * gets a url string for the streamsage thumbnail jpg - these are usually portrait in orientation		 * @param row a program object		 * @param update a Boolean, if true the poster list will update by scanning the directory, set to false for best performance		 * @example <code>Search.getPosterPath(myprogram,false);</code>		 * @returns a url string.		 */		public static function getThumbPath(row:Object,update:Boolean):String {			if (update) updateThumbList();			var isSeries:Boolean = row.entityType == "Episode" || row.entityType == "Series";			var pid:String = isSeries ? row.parentid : row.id;			var filename:String = "thumb" + pid + ".jpg";			if (thumbFileList.indexOf(filename) >= 0){				var path:String = thumbdirectory.url + "/" + filename;				return path;			}			return "";		}		/**		 * gets a url string for a recommended jpg		 * @param row a program object		 * @example <code>Search.getBestPosterPath(myprogram);</code>		 * @returns a url string.		 */		public static function getBestPosterPath(row:Object):String {			var isMovie:Boolean = row.topCategoryName == "Movies";			var path:String = Search.getPosterPath(row,false);			var lastThumbPath:String = Search.getThumbPath(row,false);			var imdbpath:String = Search.getIMDBPosterPath(row,false);			var rtpath:String = defaultTomatoPosters.indexOf(row.id) > -1 ? "" : Search.getRottenTomatoesPosterPath(row,false);			var bestpath:String = lastThumbPath;			if (isMovie){				bestpath = rtpath == "" ? imdbpath : rtpath;				if (bestpath == "") bestpath = lastThumbPath;				if (bestpath == "") bestpath = path;			}else{				bestpath = imdbpath == "" ? lastThumbPath : imdbpath;				if (bestpath == "") bestpath = path;			}			return bestpath;		}		/**		 * gets an array of imageinfo objects associated with the program passed to the function		 * each element of the array has a label property ("StreamSage Main","StreamSage Thumb","IMDB", or "Rotten Tomatoes") 		 * and a data property (containing a url string pointing to the image file)		 * @param row a program object		 * @example <code>Search.getImageList(myprogram);</code>		 * @returns an array of objects each of which has a label and data property.		 */		public static function getImageList(row:Object):Array {			//returns an array of image paths for the given program object passed to the function			var imageList:Array = new Array();			var obj:Object;			var path:String = Search.getPosterPath(row,false);			var lastThumbPath:String = Search.getThumbPath(row,false);			var imdbpath:String = Search.getIMDBPosterPath(row,false);			var rtpath:String = Search.getRottenTomatoesPosterPath(row,false);						if (path != ""){				obj = new Object();				obj.label = "StreamSage Main";				obj.data = path;				imageList.push(obj);			}			if (lastThumbPath != ""){				obj = new Object();				obj.label = "StreamSage Thumb";				obj.data = lastThumbPath;				imageList.push(obj);			}			if (imdbpath != ""){				obj = new Object();				obj.label = "IMDB";				obj.data = imdbpath;				imageList.push(obj);			}			if (rtpath != ""){				obj = new Object();				obj.label = "Rotten Tomatoes";				obj.data = rtpath;				imageList.push(obj);			}			return imageList;		}		/**		 * Updates list of images found in a folder. This is called internally only once unless images are added at runtime. 		*/		public static function updatePosterList():void {			//trace ("updating poster list");			var i:uint = 0;			posterFileList = new Array();			var plist:Array = posterdirectory.getDirectoryListing();			for (i = 0; i < plist.length; i++) {				var nativepath:String = plist[i].nativePath;				var filename:String = nativepath.substring( nativepath.lastIndexOf(File.separator) + 1, nativepath.length );				posterFileList[i] = filename;			}		}		/**		 * Updates list of images found in a folder. This is called internally only once unless images are added at runtime. 		 */		public static function updateIMDBPosterList():void {			//trace ("updating imdb poster list");			var i:uint = 0;			imdbPosterFileList = new Array();			var plist:Array = imdbposterdirectory.getDirectoryListing();			for (i = 0; i < plist.length; i++) {				var nativepath:String = plist[i].nativePath;				var filename:String = nativepath.substring( nativepath.lastIndexOf(File.separator) + 1, nativepath.length );				imdbPosterFileList[i] = filename;			}		}		/**		 * Updates list of images found in a folder. This is called internally only once unless images are added at runtime. 		 */		public static function updateRottenTomatoesPosterList():void {			//trace ("updating rotten tomatoes poster list");			var i:uint = 0;			rtPosterFileList = new Array();			var plist:Array = rtposterdirectory.getDirectoryListing();			for (i = 0; i < plist.length; i++) {				var nativepath:String = plist[i].nativePath;				var filename:String = nativepath.substring( nativepath.lastIndexOf(File.separator) + 1, nativepath.length );				rtPosterFileList[i] = filename;			}		}		/**		 * Updates list of images found in a folder. This is called internally only once unless images are added at runtime. 		 */		public static function updateThumbList():void {			//trace ("updating thumb list");			var i:uint = 0;			thumbFileList = new Array();			var plist:Array = thumbdirectory.getDirectoryListing();			for (i = 0; i < plist.length; i++) {				var nativepath:String = plist[i].nativePath;				var filename:String = nativepath.substring( nativepath.lastIndexOf(File.separator) + 1, nativepath.length );				thumbFileList[i] = filename;			}		}//---------------------------------------------------------------------------------------------------------------------------		//Utility functions here		/**		 * Optional function to communicate with a showLoadStatus function that may exist in the initializer object. 		 */		public static function showLoadStatus(txt:String):void {			if (initializer.showLoadStatus){				initializer.showLoadStatus(txt);			}		}//---------------------------------------------------------------------------------------------------------------------------		//Importing SQL tables, parsing XML, and moving data into arrays for easy and quick access		private static function importTables():void{			showLoadStatus("Importing from SQL Database. Importing table: " + tableNames[tableLoading]);			setTimeout(importNextTable,200);		}		private static function importNextTable():void{			//trace ("Received request to import: " + tableNames[tableLoading]);			selectStatement.addEventListener(SQLEvent.RESULT, importTableResults);			selectStatement.addEventListener(SQLErrorEvent.ERROR, errorHandler);			var tablename:String = tableNames[tableLoading];			var selectText:String = "";			switch (tablename){				case "programs":					selectText = "SELECT accessType as folderTypes,1 as folderCount,* from main.programs";					break;				case "linearshowings":					selectText = "SELECT * from main.linearshowings ";					break;				case "vodcategorypaths":					selectText = "SELECT * FROM vodcategorypaths WHERE path LIKE 'Movies%' OR path LIKE 'Sports%' OR path LIKE 'Kids%' OR path LIKE 'TV%'";					var incipits:Array = new Array("Premium","Top Picks","News","Music","3D","HD","En esp","Free","Help","History","Life");					for (var i:int=0;i<incipits.length;i++){						selectText += " OR path LIKE '" + incipits[i] + "%'"					}					selectText +=  "ORDER BY path";					break;				case "molt":					selectText = "SELECT * FROM main.molt WHERE similarIDS NOTNULL;";					break;				case "tomatoes":					selectText = "SELECT * FROM main.tomatoes WHERE id NOTNULL;";					break;				default:					selectText = "SELECT * from main." + tablename;					break;			}			selectStatement.text = selectText;			selectStatement.execute();		}		private static function importTableResults(event:SQLEvent):void {			var result:SQLResult = selectStatement.getResult();			var jobj:Object;			if (result.hasOwnProperty('data') && result.data != null) {				var numRows:int = result.data.length;				var tablename:String = tableNames[tableLoading];				//trace (numRows + " results found for: " + tablename);				tables[tablename] = result.data;				var i:int=0;				if (tablename == "vodcategorypaths"){					ids3D = new Array();					var list3D:String = "";					for (i=0;i<numRows;i++){						if (tables[tablename][i].path.indexOf("3D") == 0){							//trace ("Found 3D path at: " + tables[tablename][i].path);							list3D += String(tables[tablename][i].programSerialNumbers) + ",";						}					}					ids3D = list3D.split(",");					ids3D.pop();					//trace ("3D ids is: " + ids3D.toString());				}				if (tablename == "imdb"){					for (i=0;i<numRows;i++){						var ue:String = unescape(tables[tablename][i].json);						jobj = JSON.parse(ue);						tables[tablename][i].json = jobj;						tables[tablename][i].posterURL = jobj.Poster;						tables[tablename][i].description = jobj.Plot;						////trace ("IMDB recordNumber: " + tables[tablename][i].recordNumber + " Title: " + jobj.Title + " Poster: " + jobj.Poster + " id: " + tables[tablename][i].id);					}				}				if (tablename == "tomatoes"){					for (i=0;i<numRows;i++){						var ute:String = unescape(tables[tablename][i].json);						jobj = JSON.parse(ute);						tables[tablename][i].json = jobj;						var purl:String = "";												if (jobj.hasOwnProperty("posters")){							if (jobj.posters.hasOwnProperty("thumbnail")) purl = jobj.posters.thumbnail;							if (jobj.posters.hasOwnProperty("profile")) purl = jobj.posters.profile;							if (jobj.posters.hasOwnProperty("detailed")) purl = jobj.posters.detailed;							if (jobj.posters.hasOwnProperty("original")) purl = jobj.posters.original;							tables[tablename][i].posterURL = purl;							if (purl.indexOf("default") >= 0){ 								defaultTomatoPosters.push(tables[tablename][i].id);							}						}else{							tables[tablename][i].posterURL = "";						}						tables[tablename][i].critics_consensus = jobj.hasOwnProperty("critics_consensus") ? String(jobj.critics_consensus) : "";						if (jobj.hasOwnProperty("ratings")){							tables[tablename][i].critics_rating = jobj.ratings.hasOwnProperty("critics_rating") ? String(jobj.ratings.critics_rating) : "";							tables[tablename][i].critics_score = jobj.ratings.hasOwnProperty("critics_score") ? int(jobj.ratings.critics_score) : 0;							tables[tablename][i].audience_rating = jobj.ratings.hasOwnProperty("audience_rating") ? String(jobj.ratings.audience_rating) : "";							tables[tablename][i].audience_score = jobj.ratings.hasOwnProperty("audience_score") ? int(jobj.ratings.audience_score) : 0;						}					}				}				if (tablename == "programs"){					for (i=0;i<numRows;i++){						var sn:String = String(tables[tablename][i].serialNumber);						if (ids3D.indexOf(sn) >= 0){							tables[tablename][i].has3D = "true";						}						idLookup[i] = tables[tablename][i].id;						parentidLookup[i] = tables[tablename][i].parentid;					}				}				if (tablename == "linearshowings"){					for (i=0;i<numRows;i++){						var sid:String = String(tables[tablename][i].sourceID);						tables[tablename][i].channel = Search.getChannelFromSourceID(sid);						tables[tablename][i].netcall = Search.getNetcallFromSourceID(sid);					}				}				if (tablename == "molt"){					for (i=0;i<numRows;i++){						tables[tablename][i].ids = new Array();						if (tables[tablename][i].similarIDS != null && tables[tablename][i].similarIDS != ""){							var ids:Array = tables[tablename][i].similarIDS.split(",");							tables[tablename][i].ids = ids;						}					}				}			}else{				//trace("Result was null");			}			//trace ("Just loaded table number: " + tableLoading);			if (tableLoading == tableNames.length - 1){				showLoadStatus("Importing from SQL Database. Creating folders for series.");				setTimeout(createSeriesRecords,200);			}else{				tableLoading++;				//trace ("Now loading table number: " + tableLoading);				showLoadStatus("Importing from SQL Database. Importing table: " + tableNames[tableLoading]);				setTimeout(importNextTable,200);			}		}		private static function createSeriesRecords():void{			//trace ("Creating series array: ");			selectSeriesStatement.addEventListener(SQLEvent.RESULT, createSeriesRecordsResults);			selectSeriesStatement.text = "select group_concat(serialNumber) as folderIds,Count(serialNumber) as folderCount,group_concat(date1) as folderDates,min(date1) as folderDate1,min(date2) as folderDate2,group_concat(accessType) as folderTypes,* from programs where (isadult != 'true') AND (entityType = 'Series' or entityType='Episode') group by parentid,entityType,topCategoryName having folderCount>0 order by entityType DESC,parentTitle";			selectSeriesStatement.execute();		}		private static function createSeriesRecordsResults(event:SQLEvent):void {			var result:SQLResult = selectSeriesStatement.getResult();			if (result.hasOwnProperty('data') && result.data != null) {				var numRows:int = result.data.length;				//trace (numRows + " series folders found.");				infoArrays["Series"] = new Array();				infoArrays["Series"] = result.data;				for (var i:int = 0; i < numRows; i++) {					var row:Object = infoArrays["Series"][i];					var accessTypes:Array = row.folderTypes.split(",");					accessTypes.sort();					var vodCount:int = accessTypes.indexOf("vod") > -1 ? accessTypes.length - accessTypes.indexOf("vod") : 0;					var linearCount:int = accessTypes.length - vodCount;					infoArrays["Series"][i].vodFolderCount = vodCount;					infoArrays["Series"][i].linearFolderCount = linearCount;					infoArrays["Series"][i].title = infoArrays["Series"][i].parentTitle;					infoArrays["Series"][i].description = infoArrays["Series"][i].entityType == "Series" ? infoArrays["Series"][i].description : "TV Series";					seriesFolderIds.push(row.parentid);					seriesFolderIdsIndex.push(i);				}			}else{				//trace("Result was null");			}			//trace (infoArrays["Series"].length + " in infoArrays['Series'].");			showLoadStatus("Finishing up. Filtering data and storing in arrays.");			setTimeout(processTables,200);		}		/**		 * Updates every series description in the infoArray["Series"] array. This takes too much time which is one reason to just use getSeriesInfo when needed. 		 */		public static function updateSeriesDescriptions():void {			var i:int = 0;			var numRows:int = infoArrays["Series"].length;			for (i = 0; i < numRows; i++) {				//trace ("updating Series infoArray element " + i + " of " + numRows);				var row:Object = infoArrays["Series"][i];				var seriesObject:Object = getSeriesInfo(row.parentid);				infoArrays["Series"][i].title = seriesObject.parentTitle;				infoArrays["Series"][i].description = seriesObject.description;			}					}		private static function folderize():void {			//trace ("Folderizing has begun");			var arrNames:Array = new Array("Sports","Kids","Tv");			var folderizedArrays:Array = new Array();			var i:int = 0;			var f:int = 0;			var row:Object;			var cid:String;			var cidsAdded:Array = new Array();			var sfi:int = -1;			for (f=0;f<arrNames.length;f++){				folderizedArrays[f] = new Array();				for (i=0;i<infoArrays[arrNames[f]].length;i++){					row = infoArrays[arrNames[f]][i];					cid = String(row.parentid);					sfi = seriesFolderIds.indexOf(cid);					if (sfi >= 0){						if (cidsAdded.indexOf(cid) < 0){							cidsAdded.push(cid);							folderizedArrays[f].push(infoArrays["Series"][seriesFolderIdsIndex[sfi]]);						}					}else{						folderizedArrays[f].push(row);					}				}				cidsAdded = new Array();			}			infoArrays["Sports"] = folderizedArrays[0].filter(isSports);			infoArrays["Kids"] = folderizedArrays[1].filter(isKids);			infoArrays["Tv"] = folderizedArrays[2].filter(isTV);			infoArrays["allFolderized"] = infoArrays["Movies"].concat(infoArrays["Sports"]).concat(infoArrays["Kids"]).concat(infoArrays["Tv"]);			//trace ("Folderizing has ended");			showLoadStatus("Folderization complete.");		}		private static function processTables():void {			infoArrays["NotAdult"] = tables["programs"].filter(isNotAdult);			//Top Categories			infoArrays["Movies"] = infoArrays["NotAdult"].filter(isMovie);			infoArrays["Sports"] = infoArrays["NotAdult"].filter(isSports);			infoArrays["Kids"] = infoArrays["NotAdult"].filter(isKids);			infoArrays["Tv"] = infoArrays["NotAdult"].filter(isTV);			folderize();			//VOD Top Categories			infoArrays["vodMovies"] = infoArrays["Movies"].filter(isVOD);			infoArrays["vodSports"] = infoArrays["Sports"].filter(isVOD);			infoArrays["vodKids"] = infoArrays["Kids"].filter(isVOD);			infoArrays["vodTv"] = infoArrays["Tv"].filter(isVOD);			//Linear Top Categories			infoArrays["linearMovies"] = infoArrays["Movies"].filter(isLinear);			infoArrays["linearSports"] = infoArrays["Sports"].filter(isLinear);			infoArrays["linearKids"] = infoArrays["Kids"].filter(isLinear);			infoArrays["linearTv"] = infoArrays["Tv"].filter(isLinear);			//Adult			infoArrays["Adult"] = tables["programs"].filter(isAdult);			infoArrays["vodAdult"] = infoArrays["Adult"].filter(isVOD);			infoArrays["linearAdult"] = infoArrays["Adult"].filter(isLinear);			showLoadStatus("Initialization complete.");			ready = true;		}		private static function errorHandler(event:SQLErrorEvent):void {			//trace("An error occured while executing the statement.");		}		public static function parseChannels(e:Event):void {			channelXML=new XML(e.target.data);			channelData = new Array();			validSourceIDs = new Array();			validChannels = new Array();			validNetcalls = new Array();			var channelList:XMLList = channelXML.Channel.(int(@Number) < 1000);			var i:int = 0;			for (i=0;i<channelList.length();i++){				channelData[i] = new Object();				channelData[i].number = int(channelList[i].@Number);				channelData[i].id = String(channelList[i].@SourceID);				channelData[i].netcall = String(channelList[i].@SourceName);				validSourceIDs.push(channelData[i].id);				validChannels.push(channelData[i].number);				validNetcalls.push(channelData[i].netcall);			}			//trace ("validSourceIDs is: " + validSourceIDs.toString());			importTables();		}		private static function connOpenHandler(event:SQLEvent):void {			//trace ("sql connection is open");		}//---------------------------------------------------------------------------------------------------------------------------//Date Functions		/**		 * called by the init function to set up the today, tonight, tonightnum, midnight, and tomorrow6AM dates and times		 */		public static function setupDates(year:int,month:int,date:int):void {			today = new Date(year,month,date);			tonight = new Date(year,month,date,18,35);			tonightnum = tonight.time;			midnight = new Date(year,month,date+1);			tomorrow6AM = new Date(year,month,date+1,6);			//trace ("today in UTC: " + today.time + " and today in local time: " + today.toString());			//trace ("tonight in UTC: " + tonight.time + " and tonight in local time: " + tonight.toString());			//trace("tonightnum is: " + tonightnum);			//trace ("midnight in UTC: " + midnight.time + " and midnight in local time: " + midnight.toString());			//trace ("tomorrow6AM in UTC: " + tomorrow6AM.time + " and tomorrow6AM in local time: " + tomorrow6AM.toString());		}		/**		 * returns a number representing 6:35 PM of the today date		 */		public static function getTonightNum():Number {			return tonightnum;		}		/**		 * returns a number representing 12:00 AM (midnight) of the date following the today date		 */		public static function getMidnight():Date {			return midnight;		}//---------------------------------------------------------------------------------------------------------------------------//Data Preparation Functions: These functions are only used when preparing new program data for the simulator.		/**		 * THIS FUNCTION IS ONLY USED DURING DATA PREPARATION		 */		public static function getIMDBPosterFileObject(filename:String):File {			var returnFile:File = imdbposterdirectory.resolvePath(filename);			//posterdirectory.resolvePath("/" + filename);			return returnFile;		}		/**		 * THIS FUNCTION IS ONLY USED DURING DATA PREPARATION		 */		public static function getRottenTomatoesPosterFileObject(filename:String):File {			var returnFile:File = rtposterdirectory.resolvePath(filename);			//posterdirectory.resolvePath("/" + filename);			return returnFile;		}		/**		 * THIS FUNCTION IS ONLY USED DURING DATA PREPARATION		 */		public static function getPosterFileObject(filename:String):File {			var returnFile:File = posterdirectory.resolvePath("/" + filename);			//posterdirectory.resolvePath("/" + filename);			return returnFile;		}		/**		 * THIS FUNCTION IS ONLY USED DURING DATA PREPARATION		 */		public static function getThumbFileObject(filename:String):File {			var returnFile:File = thumbdirectory.resolvePath(filename);			//posterdirectory.resolvePath("/" + filename);			return returnFile;		}		/**		 * THIS FUNCTION IS ONLY USED DURING DATA PREPARATION		 */		public static function getStreamSageImageJSON(row:Object):String {			var isSeries:Boolean = row.entityType == "Episode" || row.entityType == "Series";						var rexID:String = "";			var roviID:String = "rovi$";			var allIDs:Array = row.ids.split("|");			for (var i:int=0;i<allIDs.length;i++){				if (allIDs[i].indexOf("rex") == 0){					rexID = allIDs[i].substring(3);				}				if (allIDs[i].indexOf("rovi") == 0){					roviID += allIDs[i].substring(4);				}			}			if (isSeries){				roviID = "rovi$" + row.roviSeriesid;			}			var imageURL:String = "http://tvs5.labs.streamsage.com/rex/v3/entity?q=id:";			imageURL += roviID > "rovi$ " ? roviID : rexID;			imageURL += "&filters=%28vod.location:udb.persona$6099%20OR%20tvlisting.location:ncds$2583%7C2201%20OR%20playnow.device:xfinitytv%29&fields=suggest,images&returned=1";			return imageURL;		}		/**		 * THIS FUNCTION IS ONLY USED DURING DATA PREPARATION		 */		public static function getRottenTomatoesJSON(row:Object):String {			var isMovie:Boolean = row.entityType == "Movie";			if (isMovie){				var rtURL:String = "api.rottentomatoes.com/api/public/v1.0/movies.json?q=";				rtURL += SSUtils.urlEncode(row.title);				rtURL += "&page_limit=50&page=1";				rtURL += "&apikey=ktxj4queunm99gptbvpq8vjm";//This id string for the apikey belongs to ShearSpire Media (Steven Estrella). 				//If comcast wishes to have its own id string, sign up for a developer account at developer.rottentomatoes.com				//otherwise, please don't call this function more than 10 times per second or more than 10,000 times per day				return rtURL;			}else{				return "";			}		}		/**		 * THIS FUNCTION IS ONLY USED DURING DATA PREPARATION		 */		public static function getIMDBJSON(row:Object):String {			var isMovie:Boolean = row.entityType == "Movie";			var isSeries:Boolean = row.entityType == "Episode" || row.entityType == "Series";			var rtURL:String = "";			if (isMovie){				rtURL = " http://www.imdbapi.com/?t=";				rtURL += SSUtils.urlEncode(row.title);				rtURL += "&y=";				rtURL += row.releaseYear;			}			if (isSeries){				rtURL = " http://www.imdbapi.com/?t=";				rtURL += SSUtils.urlEncode(row.parentTitle);			}			return rtURL;		}	}}